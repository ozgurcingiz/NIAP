{
    "contents" : "#'@export\nliteratureOverlapAnalysis <- function(ppi,anno,mypath=\"\") # evaluateNet <- function(net,ppi,anno)\n{\n  #mypath=paste(getwd(),\"/\",mypath,sep=\"\");\n  mypath=choose.dir(default = \"\", caption = \"Select folder\")\n  #print(mypath)\n  \n  #library(\"GAnet\");\n  \n  \n  #   file_list <- list.files(path =mypath );\n  \n  file_list=list.files(path = mypath, pattern = NULL, all.files = TRUE,full.names = TRUE, recursive = TRUE,ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE);\n  fileCount=length(file_list);\n  #print(fileCount)\n  \n  wholeInfo=matrix(data=NA,nrow=fileCount,ncol=8);\n  \n  counter=1;\n  \n  for (file in file_list)    {\n    \n    \n    \n    #temp_dataset <-read.table(file, header=TRUE, quote=\"\\\"\"); # temp_dataset <-read.table(file, header=TRUE, sep=\"\\t\")\n    \n    ################# for rda files###############\n    \n    #file_name=basename(file);\n    \n    \n    #full_name=paste(mypath,\"/\",file_name,sep=\"\")\n    \n    #jName=substr(file_name,1,nchar(file_name)-4)\n    \n    #load(file=full_name) \n    \n    #temp_dataset=get(jName)\n    \n    ####################### for text files ##########\n    \n    temp_dataset <-read.table(file, header=TRUE, quote=\"\\\"\"); # temp_dataset <-read.table(file, header=TRUE, sep=\"\\t\")\n    \n    \n    if(nrow(temp_dataset)<2) {\n      next ;\n    }\n    \n    \n    net=as.matrix(temp_dataset[1:nrow(temp_dataset),1:2]); # hata verirse sadece bu folder'da binary iliskili txt dosyalari olmali\n    net=ganet.UniqNetSimp(net);\n    \n    \n    \n    \n    temp=as.vector((anno[,2])); # rna'da 1 olacak, gexp'de 2 olacak, deneylerde de 1\n    temp=unique(temp);\n    \n    tempL=length(temp);\n    nUniverse <- tempL*(tempL- 1)/2;\n    nUniverse <- round(nUniverse/2);\n    \n    \n    \n    Validated <-ganet.ComLinks(netlist=as.matrix(net), netdata=as.matrix(ppi));\n    \n    nFocusedSet <- length( intersect(which(ppi[,1] %in% temp),which(ppi[,2]%in% temp)) );\n    \n    nOverlap=nrow(Validated);nPredicted=nrow(net); nFocusedSet=nFocusedSet;nUniverse=nUniverse;\n    \n    \n    \n    fe1 <- nrow(Validated) \n    tp=fe1;# TP\n    fe2 <- nPredicted - nOverlap # FP\n    fe3 <- nFocusedSet - nOverlap # FN\n    fe4 <- nUniverse - nPredicted - nFocusedSet + nOverlap \n    \n    recall= fe1/(fe1+fe3);\n    r=as.numeric(recall);\n    prec= fe1/(fe1+fe2);\n    p=as.numeric(prec);\n    \n    fmeasure= (2*r*p)/ (r+p);\n    \n   # print(nrow(Validated))\n    #print(nrow(net))\n    #print(nFocusedSet)\n    #print(nUniverse)\n    \n    \n    \n     fin <- ganet.FEtest(nOverlap=nrow(Validated),nPredicted=nrow(net), nFocusedSet=nFocusedSet,nUniverse=nUniverse)\n    \n    \n    \n    res <- new.env();\n    \n    assign(\"precision\", fe1/(fe1+fe2), envir = res); #assign(\"precision\", fin$precision, envir = res);\n    assign(\"tp\", fe1, envir = res);\n    assign(\"fp\", fe2, envir = res);\n    assign(\"fn\", fe3, envir = res);\n    #assign(\"pval\", fin$stats$p.value, envir = res);\n    assign(\"recall\", r, envir = res);\n    assign(\"fmeasure\", fmeasure, envir = res);\n    \n    wholeInfo[counter,1]=basename(file);\n    wholeInfo[counter,2]=fe1/(fe1+fe2);  #wholeInfo[counter,2]=fin$precision;\n    wholeInfo[counter,3]=fe1;\n    wholeInfo[counter,4]=fe2;\n    wholeInfo[counter,5]=fe3;\n    wholeInfo[counter,6]=fin$stats$p.value;\n    wholeInfo[counter,7]=r;\n    wholeInfo[counter,8]=fmeasure;\n    \n    counter=counter +1;\n  }\n  \n  colnames(wholeInfo)=c(\"name\",\"precision\",\"tp\",\"fp\",\"fn\",\"pval\",\"recall\",\"fmeasure\");\n  \n  #rm(list = setdiff(ls(), lsf.str()))\n  \n  wholeInfo\n  \n  \n  \n  \n  # res\n}",
    "created" : 1567634035172.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3755619343",
    "id" : "9E8A65CC",
    "lastKnownWriteTime" : 1567890364,
    "path" : "C:/Program Files/RStudio/workspace/NIAP/R/literatureOverlapAnalysis.R",
    "project_path" : "R/literatureOverlapAnalysis.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : true,
    "type" : "r_source"
}